## cookie的几种属性和作用
 - `name`: 名字
 - `value`: 值
 - `domain`: 可以访问此cookie的域名
 - `path`: 可以访问此cookie的路径
 - `sameSite`: 跨站点携带cookie设置
 	- None：不限制； 
 	- Lax：默认值，介于None和Strict之间，会合理判断携带cookie时机，如链接a会携带cookie；
 	- Strict：完全禁止跨站点传送cookie；
 - `httponly`: 值为true则仅在http请求中会传递cookie，不可用document.cookie等操作获取
 - `secure`: 是否只能使用https传递此cookie
 - `expires`: 过期时间；值是时间意思是到这个时间，cookie失效，否则是session，即退出浏览器后自动失效

   
## 重排和重绘  

网页加载过程大致分为5步：  
  
 1. HTML代码转化成DOM  
 2. CSS代码转化成CSSOM
 3. 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
 4. 生成布局（layout），即将所有渲染树的所有节点进行平面合成
 5. 将布局绘制（paint）在屏幕上  
 
其中第4步为排列布局，重排指的就是第4步重做；第5步是绘制，那重绘指的就是第5步重做。按照网页加载顺序，第4步之后执行第5步，所以重排必将触发重绘，而重绘不一定会触发重排。

**重绘**：修改元素字体颜色，背景颜色，阴影效果等
**重拍**：位置发生改变，如`margin` `padding` `width`。 `删除增加dom` `调用offsetHeight`等读取实时量值时

由于重排性能消耗大，那么减少重排次数也就成了一个优化页面的方法，下面总结几个常用方法：  

1. 不要一条一条修改css，尽量通过class修改，或者csstext  
2. 先display: none; 再修改样式，然后再display: block;
3. 一个元素大量修改css，可以设置为position: fixed | absolute, 这样重排消耗少，因为不用考虑其他元素位置  
4. react vue虚拟dom

## 深拷贝

```javascript
// 冷门深拷贝利用MessageChannel
function deepClone(obj) {
  return new Promise(function(resolve, reject) {
    var { port1, port2 } = new MessageChannel();
    port1.onmessage = function(e) {
      resolve(e.data);
    };
    port2.postMessage(obj);
  });
}
```
```javascript
// 利用weakmap解决了循环引用报错问题，完全版
function deepClone1(_target, map = new WeakMap()) {
  if(!_target || typeof _target !== 'object'){
    return _target
  }
  if(map.get(_target)) {
    console.log('进入map判断')
    console.log(map.get(_target))
    return map.get(_target);
  }
  let res = Array.isArray(_target) ? [] : {}; 
  console.log('map set')
  console.log(_target, res)
  map.set(_target, res);
  for(let i in _target){
    console.log('循环')
    if(typeof _target[i] === 'object'){
      console.log('是对象')
      res[i] = deepClone1(_target[i], map);
    }else{
      console.log('不是对象')
      res[i] = _target[i]
    }
  }
  return res;
}
```
## 函数防抖和节流
- **防抖**：    
  
```javascript
function debounce(event, delay) {
  let timer = null;
  return function (...args) {  // ...args用来接受fun原有的参数，比如事件就是event对象
    clearTimeout(timer); // 利用clearTimeout的特性，处理delay内，再此触发函数不做处理
    timer = setTimeout(() => {
      event.apply(this, args);
    }, delay);
  };
} 
```    

 - **节流**：  
  
```javascript
function throttle(fun, delay) {            
　　let prev = Date.now();            
　　return function(...args) {   // ...args用来接受fun原有的参数，比如事件就是event对象                        
　　　　let now = Date.now();                
　　　　if (now - prev >= delay) {                    
　　　　　　fun.apply(this, args);  
　　　　　　prev = Date.now();                                    
　　　　}            
　　}        
}
```  
[查看详解](http://cd98.xyz/d/2020/10/20/debounce-and-throttle)

## 实现换肤功能
 - 设置多种颜色类名，通过替换body元素类名实现
 - http请求动态加载.css问题
 - scss换肤 待补充 

## https证书作用 
 - 证书中存在一个公钥，一个私钥，私钥保密存在服务器不公开
 - 用户通过浏览器向服务器443端口连接，服务端收到请求，发给客户端一个带有公钥的证书
 - 客户端收到证书，先验证合法性（是否在有效期内、证书的域名与请求的域名是否匹配，通过继续，不通过提示警告
 - 客户端再生成一个随机key，通过公钥加密，发给服务端
 - 服务端收到随机key密文，用私钥解密，拿到客户端的随机key，通过随机key对内容进行对称加密，发给客户端
 - 客户端收到密文，用随机key解密，完成

## bfc

> 全称「块格式化上下文」(Block Formatting Context), 是一块独立的css作用域，外部如何变化都影响不到他。  

##### 怎么触发：  
  
 - 根元素body  
 - float： right | left
 - position： absolute | fixed
 - display：inline-block | tabel-cells | flex
 - overflow： hidden | auto | scroll
 
##### 效果
 - 清除浮动，常用overflow hidde
 - 垂直方向margin会重叠

## 数组方法
#### 改变原数组：  

 - splice: array.splice(index,howmany,item1,.....,itemX) 删除/添加
 - sort: 排序
 - unshift: 首加； shift: 首删;  pop: 尾删; push: 尾加
 - reverse: 倒序排列
 - fill: 数组填充 
 
 ```
 array.fill(value, index | 0, length | array.length)
  
 ['a', 'b', 'c'].fill(7, 1, 2) 
 // ['a', '7', '']
 ```  
 
#### 不改变原数组，生成新数组
 
 - slice: 浅拷贝 array.slice(startIdx, endIdx)
 - join: 转字符串并分割
 - toLocaleString: 转换成字符串数组
 - concat: 连接数组 可用...替代
 - indexOf: 检查下标
 - includes: 是否包含。可替代indexOf，indexOf === -1不够语义化

#### 遍历方法
  - forEach、map、filter
  - every、some、reduce、reduceRight(和reduce区别是相反方向)
   
   
   
## 字符串方法


```javascript
var str = "hello world";

str.charAt(1) //e 返回指定下标的字符
str.charcodeAt(1) //101 返回指定下标字符的字符编码
str.concat(123) // hello world123 连接字符串，生成新的
str.slice(0, 2) // he 截取字符串，参数为下标
str.substring(0, 2) // he 截取字符串，参数为下标
str.substr(0, 2) // he 截取字符串，第一个参数是起始下标，第二个参数为截取数量
str.indexOf('h', 0) // 0 查子字符下标，第一个参数是字符，第二个参数是起始下标
str.lastIndexOf('h', 0) // 0 查子字符下标，第一个参数是字符，第二个参数是结尾下标(和indexof区别)

str.toLowerCase() // hello world 转小写
str.toUpperCase() // HELLO WORLD 转大写
str.trim() // 删除前后空格

str.split('e') // ["h", "llo world"] 转数组，参数为分割符
str.replace('o', 'a') // hella world 替换字符，第一个参数可以是正则
str.match(/hello/g) // ["hello"] 匹配字符串返回一个数组，参数常是正则
```

## http1.1长连接 & http2多路复用区别：

**http1.1长连接**：**同一个域名访问同一个文件的多个请求**都可以复用一个tcp连接（不用像1.0一样 每次请求都需要重新建立连接，但不是并行，只能按顺序执行。

**http2多路复用**：**同一个域名访问多个文件的多个请求**也可以复用一个tcp连接，且多个请求可以被并行处理。  

## 懒加载
页面中一些大资源加载较慢，比如iframe，img。针对这个问题可以通过懒加载解决。    

拿`img`举例，先设置`img`的`src`属性为一个默认的资源，然后把真实`url`放在标签的某个属性中。并设置好图片的宽高，避免完成加载时出现页面闪动问题。  

然后实时监听页面滚动，如果当前图片是可见状态，那么把图片的真实url属性值取出替换到默认`src`上来实现加载图片资源，从而提升页面打开速度和合理使用客户端流量。

```javascript
// 获取浏览设备的网页可视高度
let clientHeight = document.documentElement.clientHeight; 
// 获取已被滚出的页面高度
let scrollTop = document.documentElement.scrollTop; 
// 图片顶部到网页顶部的高度
let imgOffsetTop = document.querySelector("img").offsetTop;

// 判断img在可视区域内：
imgOffsetTop < clientHeight + scrollTop
```

## vue组件通信
 - props 和 $emit
 - provide inject：在组件a声明，在a下面所有子组件通过inject调用，通过参数传递
 - event bus： new出一个vue，通过emit和on来派发和监控
 - vuex 全局状态管理
 - this.$children 和 this.$parent 层级较深不推荐，provid可以替代此方法

## 输入url到页面展示经历了什么
 - **dns解析**：按照这个步骤查询，找到ip，立即中断返回给客户端（浏览器缓存 => 操作系统缓存(host) => 路由器缓存 => isp dnf服务器查询 => 根dns服务器）
 - **tcp三次握手**
 - **发送http请求报文**：报文包括：请求行，请求头，请求体
 - **服务端接收到请求**： 进入web服务器，如apache、nginx，然后进入后台程序
 - **服务器响应报文**：报文包括：响应行，响应头，响应体
 - **浏览器渲染页面**
 	1. 根据html得到dom树
 	2. 根据css得到css树
 	3. 根据dom树和css树，生成渲染树
 	4. 根据渲染树计算每一个节点的信息
 	5. 根据计算好的信息绘制页面
 
 - **数据传送完成，四次挥手关闭**： 


## commonjs模块和es6模块有什么区别
commonjs:  

 - 对于基本数据类型，是值的拷贝
 - 对于复杂数据类型，是浅拷贝，也就是修改一个模块的值，引用他的值也会发生改变
 - 第一次加载模块会缓存，往后再加载会读取缓存的数据
 
es6：
 - 所有数据都是只读引用，当遇到import语句时，会生成一个只读引用，等到文件中真的使用到模块中的值时，根据只读引用，到加载中的模块取值
 - 不允许修改模块中的数据，并且是动态的，比如模块中的值发生改变，引入得到的值也会改变。

## 几种跨域
 - **jsonp**： 利用script标签跨域，本质是加载一个外部js
 - **cors**：全程跨域资源共享，服务端操作，把请求头的`origin`的值取出，响应头会增加`Access-Control-Allow-Origin` key并把值设置为`origin`取出的值也可以是通配符，浏览器就不会拦截响应了，从而解决跨域问题
 - **postMassage**：利用可访问服务资源的`iframe`，和当前页面互相通信，传递消息，来实现跨域，`postMassage`本质是两个页面的消息传递方法。  
   
	```javascript
	// 页面1(可以获取后端数据的)传递数据，第二个参数是url匹配规则，可以是通配符
	window.frames[0].postMessage(data,'*')
	 
	// 页面2(不能接收后端数据的)，接收页面1的数据
	window.addEventListener('message',function(e){
	console.log(e.data)
	})
	```
- **服务器中转**： 由于服务端没跨域，服务端代替客户端请求目标接口，并把响应数据返回给客户端

## react生命周期  
 
 - **componentWillMount**：在渲染前调用，客户端服务端都会调用
 - **componentDidMount**：第一次渲染后调用，只在客户端
 - **componentWillReceiveProps**： 接收新的props被调用，初始化时不会被调用
 - **shouldComponentUpdate**： 组件更新(props,state)时调用；返回布尔值，T为允许更新组件，F为不更新组件
 - **componentWillUpdate**： 组件更新(props,state)前渲染前被调用，初始化时不会调用
 - **componentDidUpdate**：组件完成更新后调用。初始化时不会被调用
 - **componentWillUnmount**： 组件要销毁前调用

 
## js变量声明提升
js中，函数及变量的声明都将被提升到作用域最顶部，且函数的提升比变量优先级高

## 继承
 - **原型链继承**： Cat继承了Animal，缺点：所有Cat实例都会共享原型链，不可以向Person传参。  
 
 	```javascript
 	function Cat(){};
 	
	Cat.prototype = new Animal();
 	```
 - **call继承**: 解决上面原型链建成俩问题，但是只是Child实例，不是Person的实例

 	```javascript
 	function Cat(name){
	  Animal.call(this);
	}
 	```
 - **组合继承**：也就是前面两个方法合并，解决上面两个继承的缺点，唯一的缺点就是继  
 
	```javascript
 	function Cat(name){
	  Animal.call(this);
	}
	
	Cat.prototype = new Animal();
	Cat.prototype.constructor = Cat; //修复构造函数指向
	// 优点：
	// 既是cat实例，又是Animal实例
	// 没有共享原型方法问题，并可以传参数

 	```
 	
## 事件循环  
 
 同步任务在执行栈，异步任务执行后回调区分微任务和宏任务放入对应的微宏队列中，等同步执行栈执行完毕，会先检查微任务队列，执行完毕后，检查宏任务队列，执行。  
 
异步微任务有哪些：  
 
  - new Promise()
    
异步宏任务有哪些：  

  - setInterval()
  - setTimeout()
 
## 前端优化
 - 静态资源放在cdn
 - 首屏加载服务端渲染
 - 可以升级到http2，可以使用http2 多路复用 多个请求并行，可以打乱顺序，最后重组
 - 使用字体图标替代图片
 - gzip压缩
 - uglify plugin优化压缩代码
 - 图片懒加载
 - 图片压缩，优先使用webp
 - 减少重排，多使用类名或者csstext处理样式
 - 多使用flex局部，性能好
  


  