## cookie的几种属性和作用
 - `name`: 名字
 - `value`: 值
 - `domain`: 可以访问此cookie的域名
 - `path`: 可以访问此cookie的路径
 - `sameSite`: 跨站点携带cookie设置
 	- None：不限制； 
 	- Lax：默认值，介于None和Strict之间，会合理判断携带cookie时机，如链接a会携带cookie；
 	- Strict：完全禁止跨站点传送cookie；
 - `httponly`: 值为true则仅在http请求中会传递cookie，不可用document.cookie等操作获取
 - `secure`: 是否只能使用https传递此cookie
 - `expires`: 过期时间；值是时间意思是到这个时间，cookie失效，否则是session，即退出浏览器后自动失效

   
## 重排和重绘  

网页加载过程大致分为5步：  
  
 1. HTML代码转化成DOM  
 2. CSS代码转化成CSSOM
 3. 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
 4. 生成布局（layout），即将所有渲染树的所有节点进行平面合成
 5. 将布局绘制（paint）在屏幕上  
 
其中第4步为排列布局，重排指的就是第4步重做；第5步是绘制，那重绘指的就是第5步重做。按照网页加载顺序，第4步之后执行第5步，所以重排必将触发重绘，而重绘不一定会触发重排。

**重绘**：修改元素字体颜色，背景颜色，阴影效果等
**重拍**：位置发生改变，如`margin` `padding` `width`。 `删除增加dom` `调用offsetHeight`等读取实时量值时

由于重排性能消耗大，那么减少重排次数也就成了一个优化页面的方法，下面总结几个常用方法：  

1. 不要一条一条修改css，尽量通过class修改，或者csstext  
2. 先display: none; 再修改样式，然后再display: block;
3. 一个元素大量修改css，可以设置为position: fixed | absolute, 这样重排消耗少，因为不用考虑其他元素位置  
4. react vue虚拟dom

## 深拷贝

```javascript
// 冷门深拷贝利用MessageChannel
function deepClone(obj) {
  return new Promise(function(resolve, reject) {
    var { port1, port2 } = new MessageChannel();
    port1.onmessage = function(e) {
      resolve(e.data);
    };
    port2.postMessage(obj);
  });
}
```
```javascript
// 利用weakmap解决了循环引用报错问题，完全版
function deepClone1(_target, map = new WeakMap()) {
  if(!_target || typeof _target !== 'object'){
    return _target
  }
  if(map.get(_target)) {
    console.log('进入map判断')
    console.log(map.get(_target))
    return map.get(_target);
  }
  let res = Array.isArray(_target) ? [] : {}; 
  console.log('map set')
  console.log(_target, res)
  map.set(_target, res);
  for(let i in _target){
    console.log('循环')
    if(typeof _target[i] === 'object'){
      console.log('是对象')
      res[i] = deepClone1(_target[i], map);
    }else{
      console.log('不是对象')
      res[i] = _target[i]
    }
  }
  return res;
}
```
## 函数防抖和节流
- **防抖**：    
  
```javascript
function debounce(event, delay) {
  let timer = null;
  return function (...args) {  // ...args用来接受fun原有的参数，比如事件就是event对象
    clearTimeout(timer); // 利用clearTimeout的特性，处理delay内，再此触发函数不做处理
    timer = setTimeout(() => {
      event.apply(this, args);
    }, delay);
  };
} 
```    

 - **节流**：  
  
```javascript
function throttle(fun, delay) {            
　　let prev = Date.now();            
　　return function(...args) {   // ...args用来接受fun原有的参数，比如事件就是event对象                        
　　　　let now = Date.now();                
　　　　if (now - prev >= delay) {                    
　　　　　　fun.apply(this, args);  
　　　　　　prev = Date.now();                                    
　　　　}            
　　}        
}
```  
[查看详解](http://cd98.xyz/d/2020/10/20/debounce-and-throttle)

## 实现换肤功能
 - 设置多种颜色类名，通过替换body元素类名实现
 - http请求动态加载.css问题
 - scss换肤 待补充 

## https证书作用 
 - 证书中存在一个公钥，一个私钥，私钥保密存在服务器不公开
 - 用户通过浏览器向服务器443端口连接，服务端收到请求，发给客户端一个带有公钥的证书
 - 客户端收到证书，先验证合法性（是否在有效期内、证书的域名与请求的域名是否匹配，通过继续，不通过提示警告
 - 客户端再生成一个随机key，通过公钥加密，发给服务端
 - 服务端收到随机key密文，用私钥解密，拿到客户端的随机key，通过随机key对内容进行对称加密，发给客户端
 - 客户端收到密文，用随机key解密，完成

## bfc

> 全称「块格式化上下文」(Block Formatting Context), 是一块独立的css作用域，外部如何变化都影响不到他。  

##### 怎么触发：  
  
 - 根元素body  
 - float： right | left
 - position： absolute | fixed
 - display：inline-block | tabel-cells | flex
 - overflow： hidden | auto | scroll
 
##### 效果
 - 清除浮动，常用overflow hidde
 - 垂直方向margin会重叠

## 数组方法
#### 改变原数组：  

 - splice: array.splice(index,howmany,item1,.....,itemX) 删除/添加
 - sort: 排序
 - unshift: 首加； shift: 首删;  pop: 尾删; push: 尾加
 - reverse: 倒序排列
 - fill: 数组填充 
 
 ```
 array.fill(value, index | 0, length | array.length)
  
 ['a', 'b', 'c'].fill(7, 1, 2) 
 // ['a', '7', '']
 ```  
 
#### 不改变原数组，生成新数组
 
 - slice: 浅拷贝 array.slice(startIdx, endIdx)
 - join: 转字符串并分割
 - toLocaleString: 转换成字符串数组
 - concat: 连接数组 可用...替代
 - indexOf: 检查下标
 - includes: 是否包含。可替代indexOf，indexOf === -1不够语义化

#### 遍历方法
  - forEach、map、filter
  - every、some、reduce、reduceRight(和reduce区别是相反方向)
   
   
   
## 字符串方法


```javascript
var str = "hello world";

str.charAt(1) //e 返回指定下标的字符
str.charcodeAt(1) //101 返回指定下标字符的字符编码
str.concat(123) // hello world123 连接字符串，生成新的
str.slice(0, 2) // he 截取字符串，参数为下标
str.substring(0, 2) // he 截取字符串，参数为下标
str.substr(0, 2) // he 截取字符串，第一个参数是起始下标，第二个参数为截取数量
str.indexOf('h', 0) // 0 查子字符下标，第一个参数是字符，第二个参数是起始下标
str.lastIndexOf('h', 0) // 0 查子字符下标，第一个参数是字符，第二个参数是结尾下标(和indexof区别)

str.toLowerCase() // hello world 转小写
str.toUpperCase() // HELLO WORLD 转大写
str.trim() // 删除前后空格

str.split('e') // ["h", "llo world"] 转数组，参数为分割符
str.replace('o', 'a') // hella world 替换字符，第一个参数可以是正则
str.match(/hello/g) // ["hello"] 匹配字符串返回一个数组，参数常是正则
```

## http1.1长连接 & http2多路复用区别：

**http1.1长连接**：**同一个域名访问同一个文件的多个请求**都可以复用一个tcp连接（不用像1.0一样 每次请求都需要重新建立连接，但不是并行，只能按顺序执行。

**http2多路复用**：**同一个域名访问多个文件的多个请求**也可以复用一个tcp连接，且多个请求可以被并行处理。  

## 懒加载
页面中一些大资源加载较慢，比如iframe，img。针对这个问题可以通过懒加载解决。    

拿`img`举例，先设置`img`的`src`属性为一个默认的资源，然后把真实`url`放在标签的某个属性中。并设置好图片的宽高，避免完成加载时出现页面闪动问题。  

然后实时监听页面滚动，如果当前图片是可见状态，那么把图片的真实url属性值取出替换到默认`src`上来实现加载图片资源，从而提升页面打开速度和合理使用客户端流量。

```javascript
// 获取浏览设备的网页可视高度
let clientHeight = document.documentElement.clientHeight; 
// 获取已被滚出的页面高度
let scrollTop = document.documentElement.scrollTop; 
// 图片顶部到网页顶部的高度
let imgOffsetTop = document.querySelector("img").offsetTop;

// 判断img在可视区域内：
imgOffsetTop < clientHeight + scrollTop
```

## vue组件通信
 - props 和 $emit
 - provide inject：在组件a声明，在a下面所有子组件通过inject调用，通过参数传递
 - event bus： new出一个vue，通过emit和on来派发和监控
 - vuex 全局状态管理
 - this.$children 和 this.$parent 层级较深不推荐，provid可以替代此方法

## 输入url到页面展示经历了什么
1. dns查询


## commonjs模块和es6模块有什么区别

## 跨域几种