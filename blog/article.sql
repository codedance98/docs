/*
 Navicat Premium Data Transfer

 Source Server         : 阿里云@8.210.115.7 香港
 Source Server Type    : MySQL
 Source Server Version : 50731
 Source Host           : localhost
 Source Database       : myProject

 Target Server Type    : MySQL
 Target Server Version : 50731
 File Encoding         : utf-8

 Date: 10/09/2020 14:11:34 PM
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
--  Table structure for `article`
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT NULL,
  `type` varchar(255) DEFAULT NULL,
  `content` longtext,
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `browse` int(11) DEFAULT '0',
  `title_en` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
--  Records of `article`
-- ----------------------------
BEGIN;
INSERT INTO `article` VALUES ('22', 'CentOs服务器部署nodejs和mysql', 'Linux,node,mySql', '## 环境\n - CentOS 7.6 64位 \n - 阿里云学生机最低配置: 1核 1G 1M \n\n \n## 安装nodeJs和npm\n通过SSH连接到服务器。进入要安装的目录，笔者这里用的`/usr/local/src`，你也可以在`/opt`下。\n这里下载的二进制包，需要编译后使用，或还可以用CentOs的包管理工具`yum`安装。这里下载的node是`10.13.0`版本的，因为本地开发就是用这个版本，你也可以安装 [nrm](https://www.npmjs.com/package/nvm) 来管理node版本\n\n```shell\ncd /usr/local/src \nwget http://nodejs.org/dist/v10.13.0/node-v10.13.0.tar.gz\n```\n完成后得到node-v10.13.0.tar.gz ，解压缩并进入目录。\n\n```shell\ntar -xzvf node-v10.13.0.tar.gz\ncd node-v10.13.0\n```\n编译前环境监测。\n\n```shell\n./configure\n```  \n如果没报错忽略这条。新服务器这里会报错，提示需要安装`g++`，它是c++的编译器，有人做了相关的编译包整合，比一个一个自己装方便，我们这里直接安装整合包，安装完成后重新执行`./configure`。\n\n```shell\nyum groupinstall \"Development Tools\"\n...\n./configure\n\n```  \n编译并安装。由于服务器配置不高，我大概等了五分钟左右。\n\n```shell\nmake && make install\n```  \n创建node和npm软连接 `ln -s 源文件 目标文件`，执行目标文件就相当于执行源文件。完成后全局可以使用node和npm命令 \n\n```shell\nln -s /usr/local/src/node-v10.13.0/bin/node /usr/local/bin/node\nln -s /usr/local/src/node-v10.13.0/bin/npm /usr/local/bin/npm\n```  \n检查软链接是否配置成功，得到版本为成功配置：\n\n```shell\nnode -v \n10.13.0\nnpm -v\n6.4.1\n```\n## 安装mysql\n- 版本5.7  \n\n由于`yum`的源中没`mysql`，需要去[mysql官网](https://dev.mysql.com/downloads/repo/yum/)找到源地址下载。\n\n```shell\nwget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm\n```\n安装源，完成后会在`/etc/yum.repos.d/`目录下增加两个文件`mysql-community.repo`和`mysql-community-source.repo`\n\n```shell\nrpm -ivh mysql57-community-release-el7-9.noarch.rpm\n```\n安装`mysql`:\n\n```shell\nyum install mysql-server\n```\n启动`msyql`：\n\n```shell\nsystemctl start mysqld\n```\n获取临时mysql密码，并登陆\n\n```shell\ngrep \'temporary password\' /var/log/mysqld.log\n...\nmysql -u root -p\n```  \n登陆成功后先修改密码：  \n\n```shell\n> ALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'你的新密码\';\n``` \n授权其他机器进行登陆本机`mysql`:\n\n```shell\n> ALTER GRANT ALL PRIVILEGES ON *.* TO \'root\'@\'%\' IDENTIFIED BY \'你的新密码\' WITH GRANT OPTION;\n  ...\n> FLUSH  PRIVILEGES;\n``` \n退出，至此，完成mysql安装。 \n\n```shell\n> exit;\n```   \n\n## 配置git拉取项目 \n\n设置git账号信息:\n\n```shell\ngit config --global user.name \"你的用户名\"\ngit config --global user.email \"你的邮箱\"\n``` \n查看git账号信息:\n\n```shell\ngit config user.name\ngit config user.email\n``` \n生成公钥和密钥，它会在`~/.ssh/`生成三个文件，其中`known_hosts`为访问记录，`id_rsa`是私钥，`id_rsa_pub`是公钥。\n\n```shell\nssh-keygen -t rsa -C \"你的邮箱\"\n``` \n复制公钥内容，添加到[Github](https://github.com/settings/ssh/new)用于鉴权。   \n位置：Github Profile > `setting` > `SSH and GPC keys` > `New SSH Key` > `Title为备注，把内容粘贴到Key表单中` > `Add SSH Key`   \n   \n```shell\ncd ~/.ssh\nvim id_rsa.pub\n``` \n\n\n\n至此服务器有权限从github获取项目了，进入/opt克隆你的项目  \n \n```shell\ncd /opt\ngit clone 你的项目ssh地址\n``` \n## 部署  \n>常规启动项目在遇到服务器重启或其他意外会直接停止服务，这非常不方便。笔者这里推荐使用[pm2](https://pm2.keymetrics.io/)来完善操作，它是一个node守护进程管理器，可利用它简化node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，很通用而且使用非常简单。  \n\n安装他:\n\n```shell\nnpm install -g pm2\n...\npm2 --version\n4.4.1\n```   \n安装依赖，并使用`pm2`启动node项目：\n\n```shell\ncd node\nnpm install\n...\npm2 start main.js --watch\n``` \n查看`pm2`列表：  \n\n```shell\npm2 list\n```    \n![WechatIMG2774.png](https://i.loli.net/2020/09/09/tsJyucP4eSFO8zH.png)  \n  \n这是启动node项目下main.js示例。在本例中app_name默认为main，若要指定名称，在后面使用--name参数，更多参数请看下段。\n\n```shell\npm2 start node/main.js\n```  \n\n更多参数:  \n\n```shell\n# 指定应用名称\n--name <app_name>\n\n# 当文件改变时，监听并重启应用(开启)\n--watch\n\n# 当文件改变时，监听并重启应用(停止)\n--watch 0\n\n# 设置应用程序重新加载的内存阈值\n--max-memory-restart <200MB>\n\n# 指定日志文件路径\n--log <log_path>\n\n# 重启延迟\n--restart-delay <delay in ms>\n\n```  \n常用命令： \n\n - `pm2 start <file_name>` 开启应用\n - `pm2 stop all  ` 	停止所有pm2应用\n - `pm2 stop <app_name> ` 	停止单个pm2应用\n - `pm2 list` 		查看所有应用状态\n - `pm2 restart <file_name>` 重启 \n - `pm2 descripe <app_name>` 查看单个应用状态\n \n\n[更多pm2命令](https://pm2.keymetrics.io/docs/usage/quick-start/#options)  \n  \n至此，部署成功了。现在开放你的node端口供公网访问，进入购买服务器官网控制台，例如笔者服务器是阿里云的，进入阿里云控制台增加安全组，添加你的node端口，保存即可。enjoy it。\n\n\n', '2020-09-09 17:09:13', '2020-10-04 11:07:53', '75', 'deploy-nodejs-and-mysql-on-centos'), ('23', 'vue和nginx服务器配置gzip', 'nginx,vue,gzip', '## 环境\n - nginx@1.19.2\n - vue-cli@4.5.0  \n \n## vue实现gzip构建配置\n安装依赖，它的作用是提供带`Content-Encoding`编码的压缩资源。\n\n```shell\nnpm install compression-webpack-plugin --save-dev\n```  \n\nwebpack配置，由于`vue-cli@2`以后隐藏`webpack.config.js`，也就是webpack的构建配置。它在内部编写了基础配置。  \n[vue-cli 文档](https://cli.vuejs.org/zh/guide/)  \n\n如果您想修改，你需要在vue根目录创建`vue.config.js`文件，像css一样，会自动覆盖隐藏的基础配置。gizp配置如下:  \n[更多参数](https://www.webpackjs.com/plugins/compression-webpack-plugin/)\n\n```shell\n// vue.config.js\nconst CompressionWebpackPlugin = require(\'compression-webpack-plugin\'); \nconst isProduction = process.env.NODE_ENV === \'production\'; // 环境判断\nconst productionGzipExtensions = [\'js\', \'css\']; // 需要gzip的文件类型\n\nmodule.exports = {\n  configureWebpack: config => {\n    if (isProduction) { // 只有生产环境才压缩gzip\n      config.plugins.push(new CompressionWebpackPlugin({\n        // 压缩算法\n        algorithm: \'gzip\', \n        // 资源匹配\n        test: new RegExp(\'\\\\.(\' + productionGzipExtensions.join(\'|\') + \')$\'), \n        // 只有大于这个大小(byte)的资源才会被处理        \n        threshold: 10240, \n        // 只有压缩率比这个值小的资源才会被处理\n        minRatio: 0.8\n      }))\n    }\n  }\n}\n```  \n#### vue-cli 3.0以下配置\n> 需要注意的是需要安装1.x.x版本，2+版本的配置项`asset`更换成了`filename`。  \n> \n> 如果你要安装2+版本到`/build/webpack.prod.conf.js`中`new CompressionWebpackPlugin`的第一个参数从`asset`修改成`filename`。\n\n```shell\n// 安装依赖\nnpm install compression-webpack-plugin@1.1.9 --save-dev\n\n// 进入/config/index.js, productionGzip参数改成true\nbuild: {\n	...\n	productionGzip: true\n}\n\n// 更多参数配置在/build/webpack.prod.conf.js\nif (config.build.productionGzip) {\n  const CompressionWebpackPlugin = require(\'compression-webpack-plugin\')\n  webpackConfig.plugins.push(\n    new CompressionWebpackPlugin({\n      ...\n    })\n  )\n}\n```  \n\n## nginx配置\n编辑nginx配置文件，我的在`/usr/local/nginx/conf/nginx.config`, 或使用`whereis nginx`查找, 得到地址找到 `conf/nginx.config`，打开配置文件，作用全局在`http块`中添加，作用单个服务在`server块`中添加。  \n\nnginx.config: \n\n```shell\ngzip  on; // on表示开启，off表示关闭；\n\n# 需要压缩的MIME类型\ngzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n```  \n[参考更多参数](https://segmentfault.com/a/1190000012694104)  \n\n编辑保存后，重启nginx来更新配置:\n\n```shell\ncd /usr/local/nginx/sbin // 进入你的nginx下sbin目录\n\n./nginx -s reload // 重启\n```  \n\n## 结果\n重新构建vue并部署到nginx。\n打开浏览器控制台，network面板，右键表头。  \n\n\n勾选`Content-Encoding`  \n\n![WechatIMG2793.png](https://i.loli.net/2020/09/10/vW36BFrLUA85bGe.png)    \n\n看到 `gzip` 即成功。\n\n![WechatIMG2794.png](https://i.loli.net/2020/09/10/FS6bBWiJQIjuHTz.png)\n', '2020-09-10 18:19:37', '2020-09-27 13:15:47', '45', 'configure-gzip-on-nginx-with-vue'), ('24', 'nginx服务器部署vue', 'nginx,vue', '## 环境\n - CentOS 7.6 64位\n - nginx@1.19.2\n - vue-cli@4.5.0  \n \n## nginx配置\n连接服务器，进入要下载的目录，这里用的`/usr/local/src`，你也可以在`/opt`下，这两种算约定俗称的目录结构，便于统一管理。\n\n下载`nginx`，这是使用的是二进制包，你可以通过`yum`包管理安装。   \n我这里用的最新的`1.19.2`版本。[更多版本](http://nginx.org/en/download.html)\n\n```shell\nwget -c https://nginx.org/download/nginx-1.19.2.tar.gz \n```\n解压缩并进入`nginx`文件夹：  \n\n```shell\ntar -zxvf nginx-1.19.2.tar.gz\n...\ncd nginx-1.19.2\n```  \n编译前环境监测：\n\n```shell\n./configure\n```  \n如果没报错忽略这条。新服务器这里会报错，提示需要安装`g++`，它是c++的编译器，有人做了相关的编译包整合，比一个一个自己装方便，我们这里直接安装整合包，安装完成后重新执行`./configure`。  \n\n```shell\nyum groupinstall \"Development Tools\"\n...  \n```  \n编译并安装：\n\n```shell\nmake && make install\n```    \n启动它：  \n\n```shell\ncd /usr/local/nginx/sbin\n./nginx\n```  \n更多常用命令：  \n\n```shell\n./nginx -s stop // 停止\n./nginx -s reload // 重启\n```\n默认`nginx`在`80端口`运行，记得到服务器购买网站控制台开放一下公网`80端口`权限。   \n \n要想修改配置：  \n\n```shell\ncd /usr/local/nginx/config\nvi ./nginx.config\n```  \n## 配置vue\n克隆你的vue项目，我是在`/opt/vue/`目录下： \n\n```shell\ncd /opt/vue\ngit clone xxx\nnpm install\nnpm run build\n```  \n\n修改nginx.config文件，找到`http`块中的`server`块。\n\n```shell\nserver {\n        listen       80;  #监听端口\n        server_name  127.0.0.1; #监听地址    \n        location / {\n            root   /opt/vue/dist; # 资源目录，我这里是vue构建后的目录\n            index  index.html index.htm; #首页文件设置\n            try_files $uri $uri/ /index.html; #vue-router history 路由设置\n        }\n        # 以下是指定错误时展示的文件文件\n        #error_page  404              /404.html; \n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n```  \n[更多nginx配置参考](https://www.runoob.com/w3cnote/nginx-setup-intro.html)\n##### 其中 \n - 设置`localtion`块的`root`属性为你的vue构建后文件    \n\n - 如果 vue 使用`history`路由，设置`try_files`为`$uri $uri/ /index.html`，用来告诉`nginx`前端路由交给前端的`index`文件去处理了，不用你处理了\n\n\n', '2020-09-12 14:43:56', '2020-09-29 11:27:19', '41', 'deploy-vue-on-nginx-server'), ('25', 'uglifyJs-webpack-plugin在vue中的使用', 'webpack,uglifyJs', '## 环境\n - vue@2.6.10\n - vue-cli@4.10  \n \n## UglifyJS Webpack Plugin  \n\n> 一个依赖[ Uglify.js ](https://github.com/mishoo/UglifyJS)来优化和压缩`javascript`代码的`webpack`插件，此插件要求的最小版本为`Node@6.9.0`和`Webpack@4.0.0`版本。  \n\n#### 安装\n```shell\nnpm install --save-dev uglifyjs-webpack-plugin\n```\n#### 使用\n```shell\n// vue.config.js\nconst UglifyJsPlugin = require(\'uglifyjs-webpack-plugin\');\n\nmodule.exports = {\n  ...\n  configureWebpack: config => {\n	config.plugins.push(\n	      new UglifyJsPlugin({\n	        uglifyOptions: {\n	          compress: { // 参Uglify.js参数\n	            warnings: true, // 警示存在安全风险的代码\n	            drop_debugger: true, // 是否过滤调试(debugger)代码\n	            drop_console: true, // 是否过滤输出(console)代码\n	          },\n	        },\n	        sourceMap: false, // 是否启用文件缓存\n	        parallel: true  // 使用多进程并行运行来提高构建速度\n	      })       \n	)\n}\n```\n[更多`compress`参数](http://lisperator.net/uglifyjs/compress)  \n\n[官方参数文档](https://www.html.cn/doc/webpack2/plugins/uglifyjs-webpack-plugin/)', '2020-09-13 18:10:25', '2020-09-29 11:27:12', '62', 'how-to-use-uglifyJs-webpack-plugin-in-vue-app'), ('26', 'Linux中内存交换空间(Swap)的使用', 'Linux,swap', '## 什么是swap\n`swap`分区是`Linux`中特殊的一种存储，他在安装系统时被自动创建。  \n\n用于当内存不够时，操作系统会取出内存中不活跃或不常用的一部分放到`swap`分区中，使内存空闲出一部分空间用于执行其他程序。相当于临时充当一部分内存，当操作系统想要访问`swap`空间上的的数据时，`swap`会把数据放回内存中供操作系统使用。\n\n类似`windows`中的虚拟内存。每个操作系统都有这种内存调度处理，当内存不够用，还想跑点东西，可以临时选择增加`swap`空间。以达到`实际使用内存`超过`物理内存`。由于`swap`的读取速度远不如内存，最好的办法还是`加物理内存`。\n## swap分区类型\n - **swap 文件**\n - **swap 分区**  \n\n速度比较：物理内存 > swap分区 > swap文件。\n\n当你的磁盘已经装了不少内容，不方便重新规划的话，也只好使用swap文件了。本文使用swap文件方式。\n\n## 查看swap信息\n> 基于Cent OS 7.6 \n\n 使用`swapon -s`命令查看系统中当前`swap`信息：  \n\n```shell\nswapon -s\n\nFilename            Type        Size     Used        Priority\n/swapfile           file        1048572  199668      -2\n``` \n - **Filename**：swap 分区/文件所在的位置\n - **Type**：swap类型；`partition`为分区类型，`file`为文件类型\n - **Size**：总容量，单位是KB\n - **Used**：已被使用的容量\n - **Priority**：优先级，越高越优先被操作系统使用\n \n若查不到 swap 信息，使用`free -h`命令，查看内存使用情况：\n\n```shell\nfree -h\n              total        used        free      shared  buff/cache   available\nMem:           487M         65M        289M         44K        132M        398M\nSwap:          1.0G        259M        764M\n```\n## 操作swap\n>\n\n创建`swap文件`， `fallocate`命令可以为文件预分配物理空间，和touch、vim的区别就是可瞬间创建超大的文件。快速创建的原因是通过分配块并将它们标记为未初始化，无需对数据块进行IO，可以快速完成预分配。当使用时再使用物理内存。`-l`后加大小，可以是k、m、g。再后面是保存位置和名称。\n   \n```shell\n# 创建一个1g文件swapfile保存到/\nsudo fallocate -l 1G /swapfile\n``` \n\n修改权限，避免误操作，仅允许文件所有者进行读写操作：\n\n```shell\nsudo chmod 600 /swapfile\n``` \n将这个文件设为 Linux 交换区：\n\n```shell\nsudo mkswap /swapfile\n``` \n激活交换区：\n\n```shell  \nsudo swapon /swapfile\n``` \n修改`/etc/fstab`，实现系统重启自动加载swap文件：  \n\n```shell\necho \'/swapfile none swap sw 0 0\' | sudo tee -a /etc/fstab\n```\n至此完成swap文件增加。使用`free -h`查看 swap 使用情况：  \n\n```shell\nfree -h\n              total        used        free      shared  buff/cache   available\nMem:           487M         65M        289M         44K        132M        398M\nSwap:          1.0G        259M        764M\n```\n停止所有swap：  \n\n```shell\nsudo swapoff -a\n\n# 查看内存使用情况，可以看到 Swap 信息都变成0，说明操作成功了\nfree -h\n              total        used        free      shared  buff/cache   available\nMem:           487M        261M         92M        484K        134M        201M\nSwap:     	  0           0           0\n```\n\n', '2020-09-21 16:48:04', '2020-09-29 16:37:56', '41', 'the-use-of-memory-swap-in-linux'), ('27', 'webpack4的使用', 'webpack', '## 前言\n**webpack** 是我经常用到的工具，并且 **webpack** 也逐渐成为主流前端构建工具，所以我觉得有必要透彻理解它，由于配置实现的写法有很多种，让人很头疼，一直没有仔细研究一下他的原理和实现方式。通过这篇文章，全面了解 **webpack**。  \n\n## webpack简介\n>**webpack** 是一个开源的前端模块构建工具，由德国开发者 *Tobias Koppers* 在2012年首发并开源。  \n\n由于近年来前端技术发展迅猛，越来越重视用户的操作体验，现在早已经不是那个 html、css、jQuery 一把梭的年代了。  \n越来越多的新思想、新框架孕育而生。这导致前端越来越重，需要 **引入依赖**、**高级语法降级解析**，**Css预编译**，**使用更为严格的**`TypeScript`**避免问题**， **使用现代 mvvm 框架**`Vue`，`React`**快捷开发**。最后 **构建** 成浏览器 **可识别** 的`.css` `.js`等基本文件再部署到生产环境，这其中构建一步就是`webpack`做的事情。 \n\n![WechatIMG2925.png](https://i.loli.net/2020/09/24/EOzt1WTKBaXkgIr.png)\n\n## webpack基础使用\n> 全局已安装 webpack@4.44.2 和 nodejs@10.13.0  \n\n主要是两个配置：\n\n- **entry**：构建入口, `webpack`会从指定文件开始识别依赖模块关系并开始构建。`webpack4`中默认入口在`/src/index.js`。\n- **output**：构建出口，告诉`webpack`，构建完的文件放在哪里，叫什么名字，`webpack4`中默认出口在`/dist/main.js`。\n\n先来演示一下webpack最基本的操作。\n新建文件夹，初始化项目`npm init` ，一路回车，生成`package.json`，在这个目录新建两个文件，`main.js`，`chunk.js` ，内容如下：  \n\nmain.js   \n\n```shell\nconst chunk = require(\'./chunk.js\');\nconsole.log(chunk);\n```  \nchunk.js\n\n```shell\nmodule.exports = \'I am chunk.js\';\n```  \n创建好之后在项目下安装webpack：\n\n```shell\nnpm install --save-dev webpack webpack-cli\n```  \n执行第一个命令，`webpack 构建入口 --output 构建出口`： \n\n```shell\n$ webpack ./main.js --output ./dist.js\n...\n...\nHash: 8cc82b2736e97001d58e\nVersion: webpack 4.44.2\nTime: 269ms\nBuilt at: 2020-09-24 16:46:34\n  Asset        Size  Chunks             Chunk Names\ndist.js  1000 bytes       0  [emitted]  main\nEntrypoint main = dist.js\n[0] ./main.js 56 bytes {0} [built]\n[1] ./chunk.js 32 bytes {0} [built]\n```   \n上命令是把`main.js`使用`webpack`打包生成`dist.js`，由于`main.js`中引入`chunk.js`，所以`dist.js`是`main.js`和`chunk.js`的整合。  \n\n可以看到`webpack`输出一些打包信息后，并成功在`./`下创建`dist.js`，看看效果，创建一个`index.html`，并引入`dist.js`\n\n当前目录结构:  \n\n```shell\n.\n├── chunk.js \n├── index.html\n├── main.js \n├── package.json \n```  \n\n打开`index.html`控制台面板可以看到向屏幕输出了「 I am chunk.js 」，看到这里，其实就可以理解`webpack`的作用了。都是在这个基础上，**变形转换**，**以及打包过程中增加一些处理**。这次简单演示使用终端打包，实际开发需要设置相当多的参数，命令不方便处理，会创建一个`webpack.conf.js`，专门来编写配置。  \n## webpack4的改变  \n\n - 速度相比3更快了(提升至少50%，没测过)\n - 默认配置出入口(就是网上说的0配置)\n - 增加了环境配置\n  \n#### 默认配置出入口\n> 这里需要说明一下，在webpack4中实现了默认配置，去除了老版本繁琐的配置，webpack真正的本领是构建，webpack官方也注意到了这一点，这是一个非常明智的改变。  \n\n版本3中需要用`entry`和`output`来指定构建入口和出口，在版本4中有默认配置。  \n\n - 默认入口在`/src/index.js`\n - 默认出口在`/dist/main.js`\n\n如果你想修改，可以在`package.json`修改script，例：  \n\n```shell\nwebpack ./entry/js/index.js --output ./output/js/main.js\n```  \n\n`webpack.conf.js`：  \n\n```shell \nconst path = require(\'path\')\n\n// 引入path为了实现相对路径转换成绝对路径：\npath.join(__dirname, \'路径\')\n\nmodule.exports = {\n  // entry为开始构建的文件入口\n  entry: path.join(__dirname, \'/src/index.js\'),\n  // output为构建后的文件出口，其中path为出口文件的路径，filename为出口文件名\n  output: {\n    path: path.join(__dirname, \'/dist\'),\n    filename: \'bundle.js\'\n  }\n}\n```  \n#### 增加了环境配置\n4以前版本配置不同环境，根据`nodejs`环境变量需要编写两套配置：开发环境中配置`live reloading` 和`webpack-dev-server`；生产环境配置`sourceMap`和`uglifyJSPlugin`美化压缩代码。在4版本中只需要在`package.json`的中`script` 增加`--mode`参数指定环境，并自动处理上面不同环境区别：\n\npackage.json：  \n\n```json\n\"scripts\": {\n  \"dev\": \"webpack --mode development\",\n  \"build\": \"webpack --mode production \"\n}\n```\n## webpack进阶使用\n主要是两个配置：\n\n- **loader**：`webpack`本身只能处理`.js`文件，安装不同的`loader`使其具备处理其他文件的能力，比如`.css`，`.scss`，`.vue`，`.jsx`，`.jade`。\n\n- **plugins**：用于处理打包过程中一些更复杂的处理，比如`htmlwebpackplugin`自动生成`index.html`并引入构建文件，`uglifyJSPlugin`美化压缩代码。  \n\n#### Loader  \n在`/css/index.css`中创建`css`文件，并在`/src/index.js`引入，`css`经过`webpack`构建后会自动作用在`index.html`上。\n\n`/src/index.css `： \n\n```javascript\nh1{\n  color:red;\n}\n```    \n`/src/index.js`：\n\n```javascript\nimport indexCss from \'./index.css\'; // 或者 import \'./index.css\';\n\nconst chunk = require(\'../chunk.js\');\nconsole.log(chunk);\n```    \n执行`webpack`，可以看到报错了：\n\n```shell  \nERROR in ./src/index.css 1:4\nModule parse failed: Unexpected token (1:4)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> html{\n|   color:red;\n| }\n @ ./src/index.js 1:0-34\n```\n你需要安装对应`loader`去处理这个`css`文件，安装`style-loader`和`css-loader`： \n\n - **css-loader**：`webpack`默认只能处理`.js`和`.json`文件类型，这个包会使`webpack`具备处理`.css`的能力  \n - **style-loader**：`style-loader`会把`css-loader`构建好的`css`作为`<style>`标签插入到`html`中。\n\n安装他们：  \n\n```shell\nnpm install style-loader css-loader --save-dev\n```  \n\n配置他们：  \n> 需要注意：loader 的执行顺序是从后往前执行，本例先执行 css-loader 返回内容再交给 style-loader 执行。链式调用，一环套一环，每个 loader 负责单一指责，方便扩展。\n\n```javascript\nmodule.exports = {\n  module: {\n    rules: [{ \n      test: /\\.css$/, \n      use: [\n        { \n          loader: \"style-loader\",\n          options: {\n            // options\n          }\n        },\n        { \n          loader: \"css-loader\" ,\n          options: {\n            // options\n          }\n        }\n      ]\n    }]\n  }\n}\n```  \n - **test**：匹配 loaders 所处理文件的拓展名的正则表达式（必填）\n - **loader**：loader 的名称（必填）\n - **include/exclude**：需要处理的文件夹或屏蔽不需要处理的文件夹（选填）；\n - **options**：为 loaders 提供额外的设置选项（选填）\n\n详细options：  \n[style-loader](https://developer.aliyun.com/mirror/npm/package/style-loader)  \n[css-loader](https://developer.aliyun.com/mirror/npm/package/css-loader)\n\n重新构建：  \n\n```shell\n➜  webpack-demo webpack\nHash: c741b4496ab2094ee570\nVersion: webpack 4.44.2\nTime: 270ms\nBuilt at: 2020-09-30 17:22:42\n  Asset     Size  Chunks             Chunk Names\nmain.js  4.7 KiB       0  [emitted]  main\nEntrypoint main = main.js\n[1] ./src/index.js 79 bytes {0} [built]\n[2] ./src/index.css 529 bytes {0} [built]\n[4] ./node_modules/css-loader/dist/cjs.js??ref--4-1!./src/index.css 301 bytes {0} [built]\n[5] ./chunk.js 32 bytes {0} [built]\n    + 2 hidden modules\n```\n构建成功了，  \n修改`index.html`引入构建后的文件，并打开，可以看到一个红色标题，loader配置生效了  \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <h1>标题</h1>\n  <script src=\'./dist/main.js\'></script>\n</body>\n</html>\n```\n### Plugin\n使用`html-webpack-plugin`和`clean-webpack-plugin`举例：  \n\n - **html-webpack-plugin**：构建时，在output目录下创建一个index.html文件，并把构建后的文件插入到html中。\n - **clean-webpack-plugin**：每次打包前自动清空output文件夹。  \n\n#### html-webpack-plugin\n安装：  \n\n```shell\nnpm install html-webpack-plugin --save-dev\n```\n`webpack.config.js`配置：  \n\n```shell\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\')\n\nmodule.exports = {\n  module: {\n    //...\n  },\n  plugins: [\n    new HtmlWebpackPlugin()\n  ]\n}\n```\n[html-webpack-plugin更多参数](https://developer.aliyun.com/mirror/npm/package/html-webpack-plugin)\n\n#### clean-webpack-plugin\n安装： \n\n```shell\nnpm install clean-webpack-plugin --save-dev \n```  \n\n`webpack.config.js`配置：   \n\n```shell\nconst CleanWebpackPlugin = require(\'clean-webpack-plugin\');\n\nmodule.exports = {\n  module: {\n    //...\n  },\n  plugins: [\n    new CleanWebpackPlugin([\'dist\'])\n  ]\n}\n```\n[clean-webpack-plugin更多参数](https://developer.aliyun.com/mirror/npm/package/clean-webpack-plugin) \n\n复杂的`plugins`配置：  \n\n```javascript\nplugins: [  \n	 new HtmlWebpackPlugin(),\n     new CleanWebpackPlugin([\'dist\'])\n]\n```\n`plugins`为一个数组，每一项都是一个插件，插件的配置都是作为参数传入，有数组也有对象类型，`plugin`不像`loader`有很明确的顺序，它类似事件绑定，按需执行。', '2020-09-24 16:56:10', '2020-10-09 08:43:38', '35', 'how-to-use-webpack'), ('29', '使用css实现圆环加载', 'css', '#### Html  \n\n```html\n<div class=\"round\"></div>\n```\n#### Css\n使用`background-image`渐变属性和动画状态的`伪元素遮盖`来实现：    \n\n```css\n.round {\n  width: 150px;\n  height: 150px;\n  border-radius: 50%;\n  background-color: #eee;\n  background-image: linear-gradient(to right, transparent 50%, blue 0);\n  position: relative;\n}\n.round::before {\n  width: 50%;\n  height: 100%;\n  content: \'\';\n  position: absolute;\n  top: 0; \n  left: 50%;\n  border-radius: 0 100% 100% 0 / 50%;\n  background-color: inherit;\n  transform-origin: left;\n  animation: spin 5s linear infinite, dye 10s step-end infinite;\n}\n@keyframes spin {\n  to { transform: rotate(.5turn); }\n}\n@keyframes dye {\n  50% { background: blue; }\n}\n```\n#### 效果\n\n![demo.gif](https://i.loli.net/2020/10/04/E8CM6WZ1hRv7piy.gif)', '2020-10-04 09:44:03', '2020-10-09 08:43:34', '3', 'realize-circle-loadingi-in-css');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
